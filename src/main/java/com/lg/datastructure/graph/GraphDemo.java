package com.lg.datastructure.graph;

/**
 * 数据结构：图
 *
 * @author Xulg
 * Created in 2020-11-17 14:02
 */
class GraphDemo {

    /*
     *无向图
     *	   ②－⑥
     *	   ｜  ｜
     * ①－③－⑤－⑦－⑨
     *     ｜     ╱
     *     ④－ ⑧
     *有向图
     *	   ②←⑥
     *	   ↓  ↑
     * ①↔③→⑤→⑦→⑨
     *     ↑     ↗
     *     ④← ⑧
     *-------------------------------------------------------------
     *-------------------------------------------------------------
     *图(Graph)结构：由顶点(节点Node)，边(Edge)组成
     * 一些概念：
     *  什么是邻接点：和当前节点X直接相连，且能到达的节点
     *                  无向图中：顶点③的邻接点有①②④⑤
     *                  有向图中：顶点③的邻接点有⑤
     *  什么是入度：  有多少节点指向X节点，X节点的入度就是多少
     *                  有向图中：顶点③的入度是3
     *  什么是出度：  从X节点出发指向多少节点，X节点的出度就是多少
     *                  有向图中：顶点③的出度是2
     *-------------------------------------------------------------
     *-------------------------------------------------------------
     *有向图如下：
     *              2
     * ╭─╮→→→→→→→→→╭─╮
     * │A │       7          │C │
     * ╰─╯←←←←←←←←←╰─╯
     * ↓  ↑                  ↓  ↑
     * ↓  ↑                  ↓  ↑
     * ↓3 ↑4               5 ↓ 1↑
     * ↓  ↑                  ↓  ↑
     * ↓  ↑       6          ↓  ↑
     * ╭─╮→→→→→→→→→╭─╮
     * │D │       9          │B │
     * ╰─╯←←←←←←←←←╰─╯
     *图结构的表示方法：
     *  1.邻接表   比较省内存空间
     *         节点的邻接点，括号中的表示边的权重
     *      A: C(2)    D(3)
     *      B: C(1)    D(9)
     *      C: A(7)    B(5)
     *      D: B(6)    A(4)
     *  2.邻接矩阵
     *      矩阵的行和列都表示节点，矩阵的值表示权重，如果值为∞表示两节点不通，值为0表示是同一个节点
     *      矩阵如下：
     *            A    B    C    D
     *       A    0    ∞   2    3
     *       B    ∞   0    1    9
     *       C    7    5    0    ∞
     *       D    4    6    ∞   0
     *  3.除此之外还有很多的表示方法
     *      例如：  [
     *                [7, 5, 4],
     *                [4, 1, 3],
     *                [3, 2, 3],
     *                [8, 2, 4]
     *              ]
     *       值表示节点编号，每个子数组从左到右分别表示[weight, from, to]，比如，
     *          [7, 0, 4]  weight = 7    fromNode = 5    toNode = 4
     *          图结构如下：
     *                     ②→8→④←7←⑤
     *                     ↓
     *                     ↓3
     *                     ↓
     *              ①→4→③
     *
     *-------------------------------------------------------------
     *-------------------------------------------------------------
     *图的遍历方式：
     *  图的遍历，不一定能访问到所有的图节点
     *  宽度优先遍历(BFS)
     *      1.利用队列实现
     *      2.从源节点开始依次按照宽度进队列，然后弹出
     *      3.每弹出一个点，把该节点所有没有进过队列的邻接点放入队列
     *      4.直到队列变空
     *  深度优先遍历(DFS)
     *      1.利用栈实现
     *      2.从源节点开始把节点按照深度放入栈，然后弹出
     *      3.每弹出一个点，把该节点下某一个没有进过栈的邻接点放入栈
     *      4.直到栈变空
     *-------------------------------------------------------------
     *-------------------------------------------------------------
     *有向无环图的拓扑排序
     * 前提：必须是有向无环图
     * 应用：事件安排，编译顺序
     * 什么是拓扑排序：
     *          ③→⑤→⑦→⑨
     *              ↑
     *              ④←⑧
     *      事件③的执行前提是事件⑤已经执行，而事件⑤又依赖事件⑦的执行......
     *      拓扑排序可以将这些事件进行排序，哪个先执行哪个后执行。
     * 实现思路：
     *      1.在图中找到所有入度为0的点输出
     *      2.把所有的入度为0的点从图中删除，继续寻找入度为0的点输出，周而复始
     *      3.图的所有点都被删除后，依次输出的顺序就是拓扑排序
     * 实现代码：com.lg.datastructure.graph.TopologySort
     *-------------------------------------------------------------
     *-------------------------------------------------------------
     *求解图的最小生成树
     * Kruskal算法
     *  实现思路：
     *      需要使用并查集这个工具
     *      1.总是从权重最小的边开始考虑，依次考察权重依次变大的边(按照权重从小到大的顺序访问边)
     *      2.当前的边要么进入最小生成树的集合，要么丢弃
     *      3.如果当前的边进入最小生成树的集合中不会形成环，就要当前边
     *      4.如果当前的边进入最小生成树的集合中会形成环，就不要当前边
     *      5.考察完所有边之后，最小生成树的集合也得到了
     * P算法
     */

    /*
     *图的面试题如何搞定
     * 图的算法都不算太难，只不过coding的代价比较高
     *  1）先用自己最熟悉的方式，实现图结构的表达
     *  2）在自己熟悉的结构上，实现所有常用的图算法作为模板
     *  3）把面试题提供的图结构转化为自己熟悉的图结构，再套用算法模板或者改写即可
     */
}
