package com.lg.algorithm.greedyalgorithm;

/**
 * 贪心算法
 *
 * @author Xulg
 * Created in 2020-11-09 13:47
 */
class GreedyAlgorithm {
    /*
     *贪心算法(这是一种算法思想，没有具体的实现标准)
     *  最自然智慧的算法
     *  用一种局部最功利的标准，总是做出在当前看来是最好的选择
     *  难点在于证明局部最功利的标准可以得到全局最优解(需要数学功底)
     *  对于贪心算法的学习主要以增加阅历和经验为主
     */

    /*
     *贪心算法求解的标准过程
     * 1.分析业务
     * 2.根据业务逻辑找到不同的贪心策略
     * 3.对于可以举出反例的贪心策略直接跳过，不能举出反例的贪心策略要证明有效性，
     *   这个证明往往是特别困难的，要求数学能力很高而且没有统一的技巧性
     */

    /*
     *贪心算法的解题套路
     * 1.实现一个不依靠贪心策略的解法X，可以使用最暴力的解法
     * 2.脑补出贪心策略A，贪心策略B，贪心策略C......
     * 3.用解法X和对数器，用实验的方式验证哪个贪心策略是正确的
     * 4.不要去纠结贪心策略的证明，除非你的数学牛逼
     * 5.贪心算法最常用的策略：大根堆，小根堆，排序
     */

    /*
     * 贪心算法的领悟靠天赋，想得到就是想得到，想不到就是想不到，很难训练出来，不可强求啊！
     */

    /*
     * 笔试中占比60%~70%
     * 面试中占比20%
     */

    /*
     * 暴力破解的套路了
     *  有点类似深度优先遍历(DFS)
     *  1.肯定要使用递归来列举所有的情况
     *  2.递归怎么写呢？
     *      原数组
     *      已使用元素集合
     *      排列结果
     *      存放排列结果的集合
     *      ---------------------------------------------------------------------------------
     *      void recurse(Object[] array, Object 排列结果, List<Object> 存放排列结果的集合) {
     *          if (退出条件) {
     *              存放排列结果的集合.add(排列结果);
     *          } else {
     *              for (int idx = 0; idx < array.length; idx++) {
     *                 新的排列结果 = 排列结果 + array[idx];
     *                 Object[] remainArray = array减掉这个已经用了的元素;
     *                 process(remainArray, 新的排列结果, 存放排列结果的集合);
     *              }
     *          }
     *      }
     *      ---------------------------------------------------------------------------------
     *      void recurse(Object[] array, List<Object> 已使用元素集合, Object 排列结果, List<Object> 存放排列结果的集合) {
     *          if (退出条件) {
     *              存放排列结果的集合.add(排列结果);
     *          } else {
     *              for (int idx = 0; idx < array.length; idx++) {
     *                  // 元素必须得是没使用过的
     *                  if (!已使用元素集合.contains(array[i])) {
     *                      // 设置这个元素已使用
     *                      已使用元素集合.add(array[i]);
     *                      新的排列结果 = 排列结果 + array[idx];
     *                      recurse(array, 已使用元素集合, 新的排列结果, 存放排列结果的集合);
     *                      // 恢复现场
     *                      已使用元素集合.remove(array[i]);
     *                  }
     *              }
     *          }
     *      }
     */
}
